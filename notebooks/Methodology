{
  "cells": [
    {
      "cell_type": "markdown",
      "id": "title",
      "metadata": {},
      "source": [
        "# MAMOB V2 ‚Äî Trend Following Multi-Assets (CAC-like)\n",
        "\n",
        "**Objectif** : construire un backtest *trend following* **long-only** multi-actifs, comparer **1 couple** vs **3 couples** de moyennes mobiles, et rendre l‚Äô√©valuation **robuste** via :\n",
        "- suppression du *look-ahead bias* (`shift(1)`),\n",
        "- contrainte **fully invested (0 cash)** via normalisation + fallback,\n",
        "- m√©triques **risk-adjusted** (CAGR, vol, Sharpe, MDD, turnover),\n",
        "- tests de robustesse : **sensibilit√© aux param√®tres** + (**option**) walk-forward IS/OOS.\n",
        "\n",
        "> Ce notebook est volontairement **court** : il documente la logique ‚Äúresearch‚Äù et les preuves principales.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "imports",
      "metadata": {},
      "outputs": [],
      "source": [
        "import pandas as pd\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import yfinance as yf\n",
        "\n",
        "plt.rcParams[\"figure.figsize\"] = (11, 4)\n",
        "pd.set_option(\"display.max_columns\", 50)\n",
        "pd.set_option(\"display.width\", 200)\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "rq",
      "metadata": {},
      "source": [
        "## 1) Research question & protocole\n",
        "\n",
        "### Research question\n",
        "Est-ce qu‚Äôune strat√©gie trend-following simple bas√©e sur moyennes mobiles, appliqu√©e √† un univers multi-actifs (CAC-like), produit une performance **risk-adjusted** sup√©rieure √† un benchmark **Buy & Hold equal-weight** ?\n",
        "\n",
        "### Hypoth√®ses test√©es\n",
        "- **H1** : le signal de trend (MA_short > MA_long) am√©liore le Sharpe vs Buy & Hold.\n",
        "- **H2** : la performance n‚Äôest pas un artefact de sur-optimisation : elle reste stable sur des variantes proches des param√®tres (sensibilit√©).\n",
        "- **H3** : 1 couple (ex: 20/100) peut √™tre plus robuste/pratique que 3 couples (moins de degr√©s de libert√©, turnover potentiellement plus faible), **et cela doit se voir dans les tests**.\n",
        "\n",
        "### R√®gles de backtest (anti-pi√®ges)\n",
        "1) **No look-ahead** : on trade √† *t+1* un signal calcul√© √† *t* via `shift(1)`.\n",
        "2) **No cash** : portefeuille toujours **100% investi** (normalisation quotidienne des poids).\n",
        "3) **Comparaison compl√®te** : on compare Trend vs Buy & Hold via rendement **et** risque (CAGR, vol, Sharpe, MDD) + turnover."
      ]
    },
    {
      "cell_type": "markdown",
      "id": "data",
      "metadata": {},
      "source": [
        "## 2) Donn√©es\n",
        "\n",
        "Pour garder le notebook **rapide**, on illustre sur un sous-univers (8 titres).  \n",
        "L‚Äôapp Flask permet de s√©lectionner un univers plus large.\n",
        "\n",
        "> ‚ö†Ô∏è Note : Yahoo Finance peut limiter les requ√™tes (rate-limit). Si √ßa √©choue, relancer plus tard / changer de r√©seau / r√©duire l‚Äôunivers."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "prices",
      "metadata": {},
      "outputs": [],
      "source": [
        "tickers = [\"AI.PA\",\"MC.PA\",\"OR.PA\",\"BNP.PA\",\"SAN.PA\",\"SU.PA\",\"DG.PA\",\"CAP.PA\"]\n",
        "\n",
        "raw = yf.download(\n",
        "    tickers,\n",
        "    period=\"15y\",\n",
        "    auto_adjust=False,\n",
        "    progress=False,\n",
        "    group_by=\"column\"\n",
        ")\n",
        "\n",
        "prices = raw[\"Close\"].dropna(how=\"all\")\n",
        "prices.tail()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "returns",
      "metadata": {},
      "outputs": [],
      "source": [
        "returns = prices.pct_change().fillna(0)\n",
        "returns.tail()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "strategy",
      "metadata": {},
      "source": [
        "## 3) Strat√©gie : signal MA + anti look-ahead\n",
        "\n",
        "### Signal\n",
        "- Signal haussier si `MA_short > MA_long` ‚áí 1\n",
        "- Sinon ‚áí 0\n",
        "\n",
        "### Pourquoi `shift(1)` ?\n",
        "Sans `shift(1)`, on utilise la cl√¥ture de *t* pour d√©cider et ‚Äútrader‚Äù √† *t* ‚Üí *look-ahead bias*.  \n",
        "Avec `shift(1)`, le signal calcul√© √† *t* s‚Äôapplique √† *t+1* : backtest m√©thodologiquement propre."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "signal_fn",
      "metadata": {},
      "outputs": [],
      "source": [
        "def ma_signal(prices: pd.DataFrame, short_w: int, long_w: int) -> pd.DataFrame:\n",
        "    \"\"\"Binary MA crossover signal, shifted by 1 day to avoid look-ahead.\"\"\"\n",
        "    ma_s = prices.rolling(short_w).mean()\n",
        "    ma_l = prices.rolling(long_w).mean()\n",
        "    sig = (ma_s > ma_l).astype(int)\n",
        "    return sig.shift(1).fillna(0)\n",
        "\n",
        "signal_20_100 = ma_signal(prices, 20, 100)\n",
        "signal_20_100.tail()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "weights",
      "metadata": {},
      "source": [
        "## 4) Portefeuille **no cash** : normalisation + fallback\n",
        "\n",
        "### Probl√®me\n",
        "Le signal donne une **exposition relative** par actif (0 ou 1 ; ou en tiers avec 3 couples).  \n",
        "Mais pour obtenir un portefeuille, il faut imposer la contrainte :\n",
        "\n",
        "\\[\n",
        "\\sum_i w_i(t)=1\n",
        "\\]\n",
        "\n",
        "### Solution (V2)\n",
        "1) On normalise les expositions chaque jour.\n",
        "2) Cas critique : si toutes les expositions sont nulles (tout bearish) ‚áí somme=0 ‚áí normalisation impossible.\n",
        "   - Fallback retenu ici : **conserver les poids de la veille** (r√©duit le churn).\n",
        "   - Au tout d√©but (pas de veille) : **equal-weight**.\n",
        "\n",
        "> Remarque : ce choix respecte l‚Äôhypoth√®se ‚Äúno cash‚Äù."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "normalize_fn",
      "metadata": {},
      "outputs": [],
      "source": [
        "def normalize_weights_no_cash_with_fallback(exposure: pd.DataFrame) -> pd.DataFrame:\n",
        "    \"\"\"Normalize exposures to fully invested weights; fallback when all exposures are 0.\"\"\"\n",
        "    exposure = exposure.clip(lower=0)\n",
        "    row_sum = exposure.sum(axis=1)\n",
        "    w = exposure.div(row_sum.replace(0, np.nan), axis=0)\n",
        "    w = w.ffill()  # keep last weights if sum=0\n",
        "    w = w.fillna(1.0 / exposure.shape[1])  # initial equal-weight\n",
        "    return w\n",
        "\n",
        "weights_1 = normalize_weights_no_cash_with_fallback(signal_20_100)\n",
        "weights_1.sum(axis=1).tail()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "backtest1",
      "metadata": {},
      "source": [
        "## 5) Backtest Trend (1 couple) + benchmark Buy & Hold\n",
        "\n",
        "On calcule :\n",
        "\\[\n",
        "r_p(t) = \\sum_i w_i(t) r_i(t)\n",
        "\\]\n",
        "et l‚Äôequity :\n",
        "\\[\n",
        "Equity(t)=\\prod_{u \\le t}(1+r_p(u))\n",
        "\\]\n",
        "\n",
        "Benchmark : Buy & Hold **equal-weight**, fully invested."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "bt1",
      "metadata": {},
      "outputs": [],
      "source": [
        "def buy_hold_equal_weight(returns: pd.DataFrame) -> pd.Series:\n",
        "    n = returns.shape[1]\n",
        "    ew = np.repeat(1.0 / n, n)\n",
        "    return (returns * ew).sum(axis=1)\n",
        "\n",
        "port_ret_1 = (weights_1 * returns).sum(axis=1)\n",
        "equity_1 = (1 + port_ret_1).cumprod()\n",
        "\n",
        "bh_ret = buy_hold_equal_weight(returns)\n",
        "bh_equity = (1 + bh_ret).cumprod()\n",
        "\n",
        "pd.DataFrame({\"Trend (20/100)\": equity_1, \"Buy&Hold EW\": bh_equity}).dropna().plot(\n",
        "    title=\"Equity curves ‚Äî Trend 1-couple vs Buy & Hold\"\n",
        ")\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "triple",
      "metadata": {},
      "source": [
        "## 6) 1 couple vs 3 couples (conviction en tiers)\n",
        "\n",
        "### Construction ‚Äú3 couples‚Äù\n",
        "On prend 3 couples (fast/medium/slow), on calcule 3 signaux binaires, puis :\n",
        "\n",
        "\\[\n",
        "exposure_i(t)=\\frac{signal_1+signal_2+signal_3}{3} \\in \\{0,1/3,2/3,1\\}\n",
        "\\]\n",
        "\n",
        "Puis on **normalise** pour rester fully invested.\n",
        "\n",
        "üëâ Ici on compare **empiriquement** : Sharpe/MDD/turnover entre 1 et 3 couples."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "bt3",
      "metadata": {},
      "outputs": [],
      "source": [
        "triple = [(12, 60), (24, 120), (48, 200)]\n",
        "\n",
        "signals = [ma_signal(prices, s, l) for (s, l) in triple]\n",
        "exposure_3 = sum(signals) / len(signals)\n",
        "\n",
        "weights_3 = normalize_weights_no_cash_with_fallback(exposure_3)\n",
        "port_ret_3 = (weights_3 * returns).sum(axis=1)\n",
        "equity_3 = (1 + port_ret_3).cumprod()\n",
        "\n",
        "pd.DataFrame({\"Trend 1-couple\": equity_1, \"Trend 3-couples\": equity_3, \"Buy&Hold\": bh_equity}).dropna().plot(\n",
        "    title=\"Equity curves ‚Äî 1-couple vs 3-couples (and Buy&Hold)\"\n",
        ")\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "metrics",
      "metadata": {},
      "source": [
        "## 7) KPIs ‚Äúpro‚Äù : performance + risque + churn\n",
        "\n",
        "On calcule :\n",
        "- **Total return**\n",
        "- **CAGR** (annualis√©)\n",
        "- **Vol annualis√©e**\n",
        "- **Sharpe (rf=0)**\n",
        "- **Max Drawdown (MDD)**\n",
        "- **Turnover moyen** (proxy co√ªts / churn)\n",
        "\n",
        "Ces m√©triques permettent une comparaison compl√®te (et pas uniquement ‚Äú√ßa monte‚Äù)."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "kpis",
      "metadata": {},
      "outputs": [],
      "source": [
        "def annualize_return(equity: pd.Series) -> float:\n",
        "    if len(equity) < 2:\n",
        "        return float(\"nan\")\n",
        "    total = equity.iloc[-1] / equity.iloc[0] - 1\n",
        "    return (1 + total) ** (252 / len(equity)) - 1\n",
        "\n",
        "def annualize_vol(ret: pd.Series) -> float:\n",
        "    return float(ret.std() * np.sqrt(252))\n",
        "\n",
        "def sharpe_ratio(ann_ret: float, ann_vol: float) -> float:\n",
        "    if ann_vol == 0 or np.isnan(ann_vol):\n",
        "        return float(\"nan\")\n",
        "    return float(ann_ret / ann_vol)\n",
        "\n",
        "def max_drawdown(equity: pd.Series) -> float:\n",
        "    peak = equity.cummax()\n",
        "    dd = equity / peak - 1\n",
        "    return float(dd.min())\n",
        "\n",
        "def turnover_from_weights(weights: pd.DataFrame) -> pd.Series:\n",
        "    return (weights - weights.shift(1).fillna(0)).abs().sum(axis=1)\n",
        "\n",
        "def kpis(name: str, equity: pd.Series, ret: pd.Series, weights: pd.DataFrame) -> pd.Series:\n",
        "    total = equity.iloc[-1] / equity.iloc[0] - 1\n",
        "    ann = annualize_return(equity)\n",
        "    vol = annualize_vol(ret)\n",
        "    sh = sharpe_ratio(ann, vol)\n",
        "    mdd = max_drawdown(equity)\n",
        "    to_mean = float(turnover_from_weights(weights).mean())\n",
        "    return pd.Series(\n",
        "        {\"Total Return\": total, \"CAGR\": ann, \"Vol\": vol, \"Sharpe\": sh, \"MaxDD\": mdd, \"Turnover_mean\": to_mean},\n",
        "        name=name\n",
        "    )\n",
        "\n",
        "kpi_table = pd.concat([\n",
        "    kpis(\"Trend 1-couple (20/100)\", equity_1, port_ret_1, weights_1),\n",
        "    kpis(\"Trend 3-couples (12/60|24/120|48/200)\", equity_3, port_ret_3, weights_3),\n",
        "    kpis(\"Buy&Hold EW\", bh_equity, bh_ret, pd.DataFrame(np.repeat(1/returns.shape[1], returns.shape[1]), index=returns.index, columns=returns.columns)),\n",
        "], axis=1).T\n",
        "\n",
        "# pretty display\n",
        "disp = kpi_table.copy()\n",
        "for col in [\"Total Return\",\"CAGR\",\"Vol\",\"MaxDD\"]:\n",
        "    disp[col] = (disp[col] * 100).round(2)\n",
        "disp[\"Sharpe\"] = disp[\"Sharpe\"].round(2)\n",
        "disp[\"Turnover_mean\"] = disp[\"Turnover_mean\"].round(3)\n",
        "disp"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "sharpe_turnover_plot",
      "metadata": {},
      "outputs": [],
      "source": [
        "plt.figure(figsize=(8,4))\n",
        "plt.scatter(kpi_table[\"Turnover_mean\"], kpi_table[\"Sharpe\"])\n",
        "for name in kpi_table.index:\n",
        "    plt.annotate(name, (kpi_table.loc[name,\"Turnover_mean\"], kpi_table.loc[name,\"Sharpe\"]))\n",
        "plt.xlabel(\"Average turnover (proxy costs)\")\n",
        "plt.ylabel(\"Sharpe\")\n",
        "plt.title(\"Trade-off: Sharpe vs Turnover\")\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "robust",
      "metadata": {},
      "source": [
        "## 8) Robustness check : sensibilit√© aux param√®tres autour de 20/100\n",
        "\n",
        "M√™me si 20/100 marche, il faut v√©rifier qu‚Äôon n‚Äôest pas sur un point ‚Äúchanceux‚Äù.  \n",
        "On teste une petite grille autour de (20, 100) et on observe la distribution des Sharpe / MDD / turnover.\n",
        "\n",
        "üëâ Si 20/100 est proche du centre d‚Äôune zone de bons r√©sultats, c‚Äôest un argument empirique fort."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "grid",
      "metadata": {},
      "outputs": [],
      "source": [
        "candidates = []\n",
        "for s in [10, 15, 20, 25, 30]:\n",
        "    for l in [80, 90, 100, 110, 120]:\n",
        "        if s < l:\n",
        "            candidates.append((s,l))\n",
        "\n",
        "rows = []\n",
        "for s,l in candidates:\n",
        "    expo = ma_signal(prices, s, l)\n",
        "    w = normalize_weights_no_cash_with_fallback(expo)\n",
        "    r = (w * returns).sum(axis=1)\n",
        "    eq = (1+r).cumprod()\n",
        "    rows.append({\n",
        "        \"pair\": f\"{s}/{l}\",\n",
        "        \"CAGR\": annualize_return(eq),\n",
        "        \"Vol\": annualize_vol(r),\n",
        "        \"Sharpe\": sharpe_ratio(annualize_return(eq), annualize_vol(r)),\n",
        "        \"MaxDD\": max_drawdown(eq),\n",
        "        \"Turnover\": float(turnover_from_weights(w).mean())\n",
        "    })\n",
        "\n",
        "grid = pd.DataFrame(rows).sort_values(\"Sharpe\", ascending=False).reset_index(drop=True)\n",
        "grid.head(10)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "grid_hist",
      "metadata": {},
      "outputs": [],
      "source": [
        "grid[\"Sharpe\"].hist(bins=18)\n",
        "plt.title(\"Sharpe distribution across MA candidates (sensitivity check)\")\n",
        "plt.xlabel(\"Sharpe\")\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "optional_wf",
      "metadata": {},
      "source": [
        "## 9) (Option) Walk-forward IS/OOS ‚Äî s√©lection d√©fendable\n",
        "\n",
        "Dans l‚Äôapplication Flask (V2), on impl√©mente un **walk-forward** :\n",
        "- split temporel : **70% IS** / **30% OOS**\n",
        "- s√©lection du meilleur couple (ou triple) sur IS (ex: meilleur Sharpe IS)\n",
        "- √©valuation report√©e sur OOS (vraie performance hors-√©chantillon)\n",
        "\n",
        "üëâ Dans ce notebook court, on ne r√©-impl√©mente pas tout le moteur walk-forward ; le code et les diagnostics sont dans l‚Äôapp.\n",
        "\n",
        "Ce que tu peux √©crire dans un reporting :\n",
        "- `IS` sert √† choisir le param√®tre\n",
        "- `OOS` sert √† juger la strat√©gie\n",
        "- on ajoute aussi une **stabilit√© OOS** en 3 blocs (Sharpe bloc1/2/3) pour √©viter qu‚Äôun bon r√©sultat d√©pende d‚Äôune seule sous-p√©riode."
      ]
    },
    {
      "cell_type": "markdown",
      "id": "issues",
      "metadata": {},
      "source": [
        "## 10) Difficult√©s rencontr√©es & solutions\n",
        "\n",
        "1) **Look-ahead bias** ‚Üí corrig√© par `shift(1)`.\n",
        "\n",
        "2) **Cash implicite** (somme des expositions < 1) ‚Üí on impose **fully invested** via normalisation.\n",
        "\n",
        "3) **Cas bearish global** (tous signaux √† 0) ‚Üí fallback **keep last weights** (r√©duit le churn) + equal-weight au d√©but.\n",
        "\n",
        "4) **Sur-optimisation des param√®tres** ‚Üí (dans l‚Äôapp) walk-forward IS/OOS + diagnostics.\n",
        "\n",
        "5) **Qualit√© / disponibilit√© des donn√©es Yahoo** ‚Üí parfois rate-limit : limiter l‚Äôunivers, relancer plus tard, batch + retries dans l‚Äôapp."
      ]
    },
    {
      "cell_type": "markdown",
      "id": "conclusion",
      "metadata": {},
      "source": [
        "## 11) Conclusion (r√©sum√© court)\n",
        "\n",
        "On est pass√©s d‚Äôun backtest simple (V1) √† une version V2 plus ‚Äúd√©fendable‚Äù :\n",
        "- backtest sans biais (shift(1))\n",
        "- portefeuille **no cash** (normalisation + fallback)\n",
        "- comparaison compl√®te Trend vs Buy&Hold (CAGR/Vol/Sharpe/MDD/Turnover)\n",
        "- preuves de robustesse : sensibilit√© aux param√®tres (grid), et (dans l‚Äôapp) walk-forward IS/OOS + diagnostics.\n",
        "\n",
        "üëâ Prochaines √©tapes naturelles : int√©grer des co√ªts explicites (slippage/fees), et tester sur un univers plus large/p√©riodes plus longues."
      ]
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}
